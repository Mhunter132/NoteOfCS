# rocketmq 消息broker存储和可靠性保证

## 消息存储

消息堆积很常见，消息存储结构决定了消息读写性能，metaq是分布式的，多个broker可以为一个topic提供服务，**一个topic下的消息分散存储在多个broker上面。他们是多对多关系。**

1. topic对应多个broker
2. 一个topic的消息存储在多个broker下

## 消息的定义

1. **id: **唯一的id，无法设置，发送出去并返回，失败则是0
2. **topic:** 消费者订阅这个主题的消息
3. **data：** 消息内容
4. **attribute：** 消息属性，是一个字符串生产者可以设置属性让消费者过滤

## 物理文件

**metaq将消息存储在本地文件中，每个文件最大大小为1G**，如果写入新的消息时，超过当前文件大小，则会**自动新建一个文件**。文件名称为起始字节大小，例如，假设文件最大尺寸为1k，有三个文件，则文件名如
下(长度为20位，不足补0)：
00000000000000000000
00000000000000001024
00000000000000002048
一个broker为多个topic服务，**这些topic的消息都存储同一个文件组中**，消息顺序写入，永远都是当前文件在写，其他文件只读。

## TOPIC索引文件

弄清消息的物理存储后，也许我们会有一个疑问：如何读取指定topic的当前消息？的确，仅仅只存储消息是无法做到这个的，所以metaq还有索引文件，类似数据库的索引，但是有很大区别。broker将消息存储到文件后，会将**该消息在文件的物理位置，消息大小，消息类型封装成一个固定大小的数据结构**，暂且称这个数据结构为索引单元吧，大小固定为16k，消息在物理文件的位置称为offset。

索引单元结构

![1567935492819](D:\Documents\Markdown文档\MQ\1567935492819.png)

多个索引单元组成了一个索引文件，索引文件默认固定大小为20M，和消息文件一样，文件名是起始字节位置，写满后，产生一个新的文件。

## 逻辑分区

一个逻辑分区实际上是一组索引文件。一个topic在一个broker上可以有多个逻辑分区，默认为1，但可自由配置。为什么会有多个分区的情况？逻辑分区（分片查找）的作用不仅仅是通过索引提供快速定位消息的功能，它还跟整个metaq的集群有很大的关系。

逻辑分区示意图

![1567935519131](D:\Documents\Markdown文档\MQ\1567935519131.png)

# 集群与负载均衡

## Topic分布

**一个topic可以分布在多台broker上**，具体体现就是多个broker配置了这个topic，并且最少有一个分区。假如有一个topic名为”t1”，两个broker：b1,b2；每个borker都为t1配置了两个分区。那么t1一共有4个分区：b1-1,b1-2,b2-1,b2-2。生产者和消费者对topic发布消息或消费消息时，目的地都是以分区为单位。当一个topic消息量逐渐变大时，可以将topic分布在更多的borker上。某个broker上的分区数越多，意味着该borker承担更繁重的任务，分区数可以认为是权重的表现形式。

## 生产者

生产者在**通过zk**获取分区列表之后，会按照brokerId和分区号的顺序排列组织成一个有序的分区列表，**发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息**。这是默认的分区策略，考虑到我们的broker服务器软硬件配置基本一致，默认的轮询策略已然足够。如果你想实现自己的负载均衡策略，可以实现上文提到过的PartitionSelector接口，并在创建producer的时候传入即可。在broker因为重启或者故障等因素无法服务的时候，producer通过zookeeper会感知到这个变化，将失效的分区从列表中移除做到fail over。因为从故障到感知变化有一个延迟，可能在那一瞬间会有部分的消息发送失败。

## 消费者

消费者的负载均衡会相对复杂一些。我们这里讨论的是单个分组内的消费者集群的负载均衡，不同分组的负载均衡互不干扰，没有讨论的必要。 消费者的负载均衡跟topic的分区数目紧密相关，要考察几个场景。

- 首先是，单个分组内的消费者数目如果比总的分区数目多的话，则多出来的消费者不参与消费

![1567935540714](D:\Documents\Markdown文档\MQ\1567935540714.png)

- 其次，如果分组内的消费者数目比分区数目小，则有部分消费者要额外承担消息的消费任务，具体见示例图如下

![1567935559889](D:\Documents\Markdown文档\MQ\1567935559889.png)

# 可靠性保证

## 生产者可靠性保证

消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个**同步**的过程。保证消息送达服务器并返回结果。返回发送失败，则需要业务方来考虑处理方式。

## broker可靠性保证

消息生产者发送的消息，meta服务器收到后在做必要的校验和检查之后的第一件事就是写入磁盘，写入成功之后返回应答给生产者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。 写入磁盘，不意味着数据落到磁盘设备上，毕竟我们还隔着一层os，**os对写有缓冲**。Meta有以下刷盘策略：

异步刷盘
每1000条（可配置），即强制调用一次force来写入磁盘设备。
每隔10秒（可配置），强制调用一次force来写入磁盘设备。

同步刷盘
此外，如果存储配置上的groupCommitEnable选项为true，则会在写入消息后，立即强制刷盘。

## 消费者可靠性保证

消费者**顺序消费**，只有在成功消费一条消息后才会接着消费下一条。如果在消费某条消息失败（如异常），则会尝试重试消费这条消 息（默认最大5次），超过最大次数后仍然无法消费，则将**消息存储在消费者的本地磁盘，由后台线程继续做重试**。而主线程继续往后走，消费后续的消息。因此， 只有在MessageListener确认成功消费一条消息后，meta的消费者才会继续消费另一条消息。由此来保证消息的可靠消费。

消费者的另一个可靠性的关键点是**offset的存储**，也就是拉取数据的偏移量。默认存储在zoopkeeper上，zookeeper通过集群来保证数据的安全性。**Offset会定期保存**，并且在每次重新负载均衡前都会强制保存一次，因此可能会存在极端情况下的消息的重复消费。