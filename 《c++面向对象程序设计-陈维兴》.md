---
title:  cpp面相对象程序设计
date: 2019-11-06
categories: 
- cpp
tags: 
- 笔记
---




# 第1章 面向对象程序概述

## 1.1什么是面向对象程序设计

### 1.1.1面向对象程序设计的基本概念

### 1.1.2面向对象程序设计的基本概念

## 1.2对象与类

### 1.2.1对象与类的概念

### 1.2.2对象的状态

### 1.2.3对象的交互

### 1.2.4类的确定和划分

## 1.3数据的抽象与封装

### 1.3.1现实世界中的抽象和封装

### 1.3.2书库的抽象与封装的基本概念

### 1.3.3对象的特性

## 1.4继承性

### 1.4.1继承的概念

### 1.4.2类的分类

### 1.4.3继承和封装的关系

## 1.5多态性

### 1.5.1什么是多态

不同对象收到相同信息时表现出的不同行为

### 1.5.2 重载的概念

目的：更好的表达行为共享

## 1.6面向对象程序设计的语言

# 第二章 c++概述

## 2.1 c++的起源和特点

### 2.1.1c++的起源

### 2.1.2 c++的特点

## 2.2c++源程序的构成

### 2.2.1 c++程序的一般格式

### 2.2.2 c++程序的结构特点

## 2.3 c++在面向对象方面的一些特性

### 2.3.1注释行

### 2.3.2 新的I/O流(iostream.h)

cin>>：是标准的输入流（一连串的输入要用空格，回车tab键）

cout<<：是标准的输出流

### 2.3.3灵活的局部变量声明

### 2.3.4 结构、联合、枚举名可直接作为类型名

类型  变量名

### 2.3.5 const修饰符

1. 指向常量的指针

   指针可以移动，但是指针的指向的值不可以改变

   ```
   const  char *  name  = "张士明";
   ```

2. 常指针

   本质是指针，但是不可以移动指针，但是可以改变指针指向的内容

   ```
   char * const name = "张士明";
   ```

3. 指向常量的常指针

   指针不可以移动，内容也不可以改变

   ```
   const char * const name = "张士明";
   ```

小结：

	1. const int LIMIT = 30; int  可以省略
  2. 常量创建就不能更改，默认初始值0，以后也不允许再赋值

  3. const 相对于 #define 具有自己的数据类型，具有良好的编译检查性

  4. 建议用const 取代#define 

  5. 函数参数也可以用const，保证实参在函数内不被改变

  6. ```
     const int size = 100;
     int [size]; 在c++中是可以的，但是在c中不可以 
     ```

     

### 2.3.6 内置函数

使用内置函数前需要完整定义

```
inline float circle (){} //通常写在主函数前面
```

#define 宏定义的代码是直接展开的

```
#define dou(X) X*2 
```

用内置函数代替宏定义来消除其不安全性。通常只有较短函数才会用内置函数

### 2.3.7 函数原型

函数原型是一条语句，定义函数之前必须要预先说明

1. 函数原型的形参可以只写变量类型
2. 函数定义要写函数体
3. 无返回值类型默认是int类型
4. 原型说明中F（）等价于 F（void）
### 2.3.8 带有缺省参数的函数（形参默认参数）

1. 默认参数必须出现在非默认参数的右边
2. 默认可以出现给前面的值（从左向右），而不给后面的值，反过来不行

### 2.3.9 函数重载

### 2.3.10 作用域运算符“：：”

局部变量在局部内的优先权大于全局变量，想在局部变量中应用就熬使用 ：：+ 局部变量

### 2.3.11 无名联合

```
union{
	int i;
	float f;
} 可以直接使用变量名使用
```

### 2.3.12 强制类型转换

### 2.3.13 new 和 delete 

```
p = new type    //分配内存指向p
delete p        // 释放掉指针对应的存储空间
```

new 和delete 相对于malloc和free的优点

1. new 可以自动计算字节数

2. 能自动返回相应的指针类型

3. new还会初始化对象，放在后面的圆括号内（）

4. new数组要指定大小，多维数组必须都指定大小，int * pi  = new int [i ] [3] [4] 可以是表达式

5. delete [ ] p 不需要指定大小

6. 空间不够new 会返回null

### 2.3.14 引用

1. 引用定义

   ```
   int i = 5;
   int &j = i;  j是i的别名，且定义引用要立即初始化
   ```
2. 方便书写
3. 引用不可以重新赋值
 ```c++
 int i ,j;
 int k&=i;
 j = &k;
 ```
4. 引用不同于，如下声明式非法的
   - int &b[3];不能建立引用数组
   - int &* p; 不能建立引用的指针
   - int &&r; 不能建立引用的引用
5. 引用参数----->可以获取引用的地址
6. 可以进行地址传递
 void swap (int *a,int *b){} //传地址
 swap(&a,&b); //传地址
---------------------
​		 void swap(int &a,int &b){}
 		swap(a,b);

 7. 引用返回值
 int &index(int); //声明一个返回引用的函数就可以放在赋值运算符的左面，不可以返回一个局部变量的引用【不是返回的证书是引用】

# 第三章

## 3.1 类和对象的基本概念

### 3.1.1 结构与类

1. 结构的扩充
2. 类的声明

### 3.1.2 成员函数的定义

1. 第一种方式：是在类外定义

   ```
   返回类型  类名 ：：函数名（参数类表）｛
   	//函数体
   ｝
   ```
 2. 第二种方式：定义在内部
   - 隐式定义 ：直接在内部定义函数，内置函数是在调用出展开而不是调用（java定义式）
   - 显示定义：为了能有隐式定义的好处，仍是在内部声明，但是是在外部定义
   ```
   inline  返回类型  类名 ：：函数名（参数类表）｛
   	//函数体
   ｝
   ```
### 3.1.3 对象的定义及引用
 1.类与对象的关系
 2.对象的定义
 可以在定义的时候指定，也可以用变量进行声明
 3. 对象的引用
    （1） op1.setpoint()和   op1::setpoint()的等价的
    （2） 指针使用成员函数   char *op; op->setpoint(1,2);
 4. 对象赋值语句
    同一个类的实例之间可以相互拷贝。
### 3.1.4 类的作用域
1. 成员变量和局部变量的区别
## 3.2 构造函数与析构函数
### 3.2.1 构造函数
1. 构造函数与类名相同
2. 无返回值类型，void也不行
3. 声明对象时编译器会自动的调用的构造函数，无参构造函数产生的值是随机的所以给其赋初始值是很重要的
4. 允许无参数构造函数
5. 利用构造初始化表对函数进行构造
```
class A {
 int i ;
 int j;
 float f;
 public:
 	A(int I,char J,Float F){
 	i=I,j=J,f=F
 	};
}
等价于
class A {
 int i ;
 int j;
 float f;
 public:
 	A(int I,char J,Float F)：i(I),j(J),f(F){};
}
给数组赋值
class A {
 int i ;
 char c;
 float f;
 char name[25]; 
 public:
 	A(int I,char J,Float F,char N[])：i(I),c(C),f(F)
 	{strcpy,N}
}
```
 6. 对没有定义构造函数的类，其公有数据类型可以使用初始值表进行初始化。



## 【这里缺东西】



### 3.3.3 this指针

## 3.4 向函数传递对象

形参要使用指针进行引用

```
// 定义sqr()函数
sqr（tr * p）{
//函数体
}
```



## 3.5 静态成员

### 3.5.1静态数据成员

```
//可以自己定义输出函数并调用，使程序更容易理解
```

1. 使用 类：：静态数据成员

2. 不能在类中进行初始化，放到类外面将初始化，数据存放在其他地方缺省时会被初始化为零

3. 不依赖对象被访问

   ```
   比如：类外定义 int Myclass :: i ;
   ```

   

### 3.5.2 静态成员函数

1. 静态成员函数可以定义成内嵌的，在类外定义不用static.

2. 命名空间独立

3. 不用new对象就像就可以使用静态成员函数

4. 成员函数都有一个new指针。

   类名: : 函数名（）

5. 静态成员访问非静态成员需要使用 ｛对象.变量名｝这种类型

## 3.6 友元

友元可以是不属于任何类的一般函数，也可以是另一个的函数，还可以是整个类

### 3.6.1 友元函数

友元函数不是当前函数的成员函数，但是可以访问这个类的所有数据，包括私有数据和公有数据

```
class girl{
	private :
		char *name;
		int age;
	public:
		girl(char *p,int d){
			name = new char[strlen()+1];
			strcpy(name,n);
			age=d;
		}	
		friend void disp(girl &){
			~girl();
			{delete name ;}
		}
		
};
void disp(girl &x){
	count<<"girl\'s name is :"<<x.name}

}
void main(){
girl e("chen xin",18);.
disp(e);
}
```

1. 不是成员函数，在外部定义可以不使用 ：： 
2. 无法使用this引用朋友的成员，需要在函数参数入口处传入对象，这样在函数体内可以访问朋友的成员参数。
3. 一个函数是多个类的友元函数。prd是boy和girl的友元函数。就可以访问到girl和boy的参数。例如输出。
4. 友元函数直接访问函数的私有成员提高了代码效率，但是破坏了代码的隐蔽性



### 3.6.2 友元成员

某个类的成员函数也可以作为友元，可以访问朋友家的私有成员，公共成员

1. 声明友元成员函数之前要先声明这个类
2. 晚定义还想先用就需要先声明

### 3.6.3 友元类

当一个类被声明为另一个类的友元的时候，他的所有成员都成为另一类的友元函数

1. 友元关系是单向的
2. 友元关系不具有传递性

## 3.7 类对象作为成员

跟普通的数据成员的初始化是一样的，只不过是换成了对象成员，成员初始化用逗号隔开

1. 用之前要先声明
2. 必须要对成员对象进行初始化，与基本数据类型初始化无差异。

# 第四章 派生类和继承

## 4.1 派生类的概念

### 4.1.1 为什么要使用继承

### 4.1.2 派生类的声明

```
class 派生类名 ：派生方式  基类名｛
	//
｝
```

1. 公有派生和私有派生都不允许访问私有数据成员

2. 共有派生：所有的公有成员在派生类中是公有成员

   私有派生：所有的公有成员在派生类中是私有成员

3. ​    私有派生：派生类的公有成员函数还是不能访问基类私有成员

```
class x{
private :
	x;
public：
	setx();
	sety();
	show();
}
class y: private x{
	private:
		y;
	public :
	showxy(){
	show();
	cout<<y<<endl;
	}
}
```

- 公有派生：

  ​	私有还是私有，公有还是公有

​          当出现子类重写的时候，会走总类重写。但是如果想使用父类的同名方法就要使用 ( : : )符号

### 4.1.3 保护成员的作用

​		保护成员函数可以被派生类的成员函数访问，但是对于外界是隐藏起来的，外部函数不能访问，所以可以将基类私有成员中需要提供给派生类访问的成员定义为保护成员。

## 4.2 派生类的构造函数和析构函数

### 4.2.1 派生类构造函数和析构函数的执行顺序

构造函数执行顺序：基类然后是派生类

析构函数执行顺序： 派生类然后是基类

### 4.2.2 派生类构造函数和析构函数的构造原则

当基类构造不带参数时，派生类不一定需要定义构造函数，然而当基类的构造函数只带一个参数，他所有的派生类都必须定义构造函数，允许派生类对象为空

## 4.3 多重继承

### 4.3.1 多重继承的声明

```
class z:public a,public b{
//
};
```

x是公有继承，y是私有继承那么z里面就不能使用y的数据。

x中分f()和y中的分f()公有继承带z那么z是要使用f()就必须指定是哪个类的才能唯一确定是哪个函数

### 4.3.2 多重继承的构造函数与析构函数

多继承跟单继承的结果无任何区别

### 4.3.3 虚基数

1. base中有public int b,  x 和y 继承了base，又有m继承了x和y那么就会产生二义性。
2. 虚基类的概念
3. 虚基类的初始化在同一层次按照声明的先后顺序调用，
4. 虚基类由非虚基类派生而来仍需要先调用基类的构造函数，再调用派生类的构造函数
5. 若同一层包含有虚基类和非虚基类，应先调用虚基类再调用非虚基类的构造函数。

```
class X: public Y,virtual public z{
	//
}
X one; 将会产生如下调用次序，Z(),Y(),X()
```

因为base是虚基类因此要求这个在派生类base1,base2,derived的构造函数中都必须带一个初始化表，构造了base显然对base1和base2的构造就忽略了。

1. 关键字virtual与派生方式关键字的执行先后顺序无关紧要，它只是说明是“虚拟派生”,

   ```
   public virtual 和 virtual public 是等价的
   ```

2. 自己是非虚基类但是以虚基类的方式派生这种是允许的

## 4.4 应用【没写东西】

# 5. 第五章

## 5.1 编译时的多态性和运行时多态

## 5.2 函数重载

c++用名字压延来区别重载函数

## 5.3 运算符重载

### 5.3.1 类以外的运算符重载

```
operator+ {}
调用方式：
	1.con2;con1+con2;con2;
	2.total = con1+con2;
```

### 5.3.2 成员运算符函数

声明 ：

```
class X ｛
	type operator@(参数表);
｝
```

定义 ：

```
type X:: operator@(参数列表)｛
	//函数体
｝
```



2. 双目运算符重载

   （+ | - | * | /）

3. 单目运算符

   ```
    ++ob 和 ob.operator++()是等价的
   ```

### 5.3.3 友元运算符函数

1. 友元运算函数定义的语法形式

```
声明友元运算符函数在类的内部声明格式
friend type operator@();
定义友元运算符函数
type operator@(){
// to-do
}
*不是类函数所以不需要缀上类名。
```
2. 双目运算符重载

​       重载的是双目运算符两个参数都要传递

3. 单目运算符重载

​       若重载的是单目运算符就有一个参数，

友元运算符重载无法将this指针传递给友元运算符函数所以需要用**引用参数**传递，.

1. 其中不可以用友元函数重载的运算符是 = （）【】 ->

### 5.3.4 成员运算符函数与友元运算符的比较

1. 可以对成员友元运算符进行重载进而达到满足**整数+对象**的情况。
2. ![1571753758939](https://gitee.com/kirk_zhang/KirkzhangBlog/raw/master/images/《c++面向对象程序设计》/c++成员运算符.png)

### 5.3.5 “++”和“--”的 重载

区分++ob和区分ob++参数中传int来代替。

### 5.3.6 赋值运算符“=”的重载

1. “=”运算符只能重载为成员函数，而不能重载为友元函数，如果将“=”生命为友元函数就会解析为operator =(p1,"chen"),双目运算符应重载为成员函数的形式，而不能重载为友元函数的形式。
2. 类的赋值运算符可以被重载，但重载了的运算符函数operator=（）不能被继承

### 5.3.7 函数调用运算符“（）”与下表运算符的重载“【】”的重载

1. 重载运算符（）
2. 重载运算符【】

对下标运算符重载定义只能使用成员函数，不能被定义为友元函数

### 5.3.8 类型转换

1. 系统预定义类型间的转换

   隐式转换-->从低到高转化

   显示类型转换

2. 类类型与系统预定义类型间的转换

   1.构造函数  

   2.类类型转换函数：引用类型转换成基本类型

   3.运算符重载与类型转换

让友元函数运算符重载来干这种脏活

## 5.4 虚函数

### 5.4.1 引入派生类后的对象指针

1. 基类指针不可以指向私有子类，可以指向公有
2. 基类指针只能访问公有派生过来的基类，不能访问子类成员，**若想访问公有派生必须转型**

### 5.4.2 虚函数的定义及使用

1. 虚函数的作用

   想指向派生类就必须强制转换

2. 虚函数就可实现这种多态的作用

   virtual 

   1. 子类重写虚函数时可以不写virtual
   2. 重写时候的定义必须相同
   3. 虚函数不能是友元函数
   4. 构造函数不能是虚函数

3. 虚函数与重载的关系

   即使是虚函数如果重载虚特性就会消失。
   
4. 多继承与虚函数

   定义了什么指针就表现出什么特性。申明了虚函数指针指向子类就走多态，如果父类重载那么指向子类那么就表现出重载的特性

5. 虚函数举例子

6. 纯虚函数和抽象类

   纯虚函数时基类中申明的函数

   ```
   virtual type func_name(参数表) = 0；
   ```

   1. 抽象类可以声明执行抽象类的指针或者引用。
   2. 没有实现抽象类仍是抽象类

# 第六章

## 6.1 模板的概念

## 6.2 函数模板与模板函数

### 6.2.1 函数模板的声明与模板函数的生成

```
template <class  type>  //必须有class,且中间不能有其他语句
返回类型 函数名（）｛
	//函数体
｝
```

实例化的函数模板

```
template< class T> 
T max (T x,T y)
{
	return (x>y) ? x : y ;
} 
可以表示一类的函数
```

1. 必须有class
2. template跟定义之间不能有其他语句
3. 重载是执行不同动作，函数模板是执行相同动作

### 6.2.2 函数模板的异常处理

函数模板的形参T可以实例化为各种类型，，且类型必须一致。

1. 强制类型转换

   max( i , c  )  改写成 max(i, int ( c ) )

2. 非模板函数重载函数模板有两种方式

   - 只写声明而不写函数体，会自动调用函数模板，可以适应函数模板参数类型不一致的情况
   - 定义一个 完成的非模板函数，走定义的函数

3. c++函数模板和非模板函数重载时调用的顺序

   - 找定义的过的函数
   - 找函数模板
   - 参数转换符合条件的就调用

## 6.3 类模板 与模板类

定义类模板同时也可以定义模板函数

1. 定义类模板都需要加上模板声明

   ```
   template <class Type>
   ```

使用的时候要缀上具体类型
2. 可以使用多个模板参数

## 6.4 实际应用

# 第七章 c++的i/o流类库

## 7.1 c++为何建立自己的输入输出系统

## 7.2 c++的流及流类库

### 7.2.1 c++的流 



1. streambuf类

streambuf提供物理设备的接口，缓冲区由一个字符序列和两个指针组成，分别指向插入和取出的地方。

![1572571704656](https://gitee.com/kirk_zhang/KirkzhangBlog/raw/master/images/《c++面向对象程序设计》/c++streambuf.png)

**filebuf：**类使用文件来保存缓冲区的字符序列。当写文件时实际上是将缓冲区的字符写进指定文件，之后刷新缓冲区，当读文件时，实际是指文件中的内容读到缓冲区。将filebuf同某个文件的描述字相联系就称打开文件

**streambuf：**提供了在内存中进行提取和插入操作的缓冲区管理。

**conbuf：**扩展了streamof类的功能，用于处理输出，提供控制光标，设置颜色，定义活动窗口，清屏，清一行等功能，为输出操作提供缓冲区管理

2. ios类

   为用户提供使用流的接口

## 7.3 输入输出的格式控制

### 7.3.1 用ios类的成员函数进行格式控制

```
enum{
skipws =0x0001, //跳过输入空白
left  = 0x0002,//左对齐输出
right = 0x0004, //右对齐输出
internal = 0x0008, //在符号位和基指示符号后面填入字符
dex = 0x0010, //转换为十进制
oct = 0x0020, // 转换为八进制
hex = 0x0040, // 转换为十六进制
showbase  = 0x0080, //在输出时显示基指示位，可用于输入和输出
showpoint = 0x0100, //在输出时显示小数点

}
```

